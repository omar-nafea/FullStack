# Database Schema Comprehensive Learning Guide

## Table of Contents
1. [Foundational Concepts](#foundational-concepts)
2. [Core Components & Elements](#core-components--elements)
3. [Design Principles & Best Practices](#design-principles--best-practices)
4. [Practical Design Process](#practical-design-process)
5. [Real-World Examples](#real-world-examples)
6. [Tools & Implementation](#tools--implementation)
7. [Common Pitfalls & Solutions](#common-pitfalls--solutions)

---

## 1. Foundational Concepts

### What is a Database Schema?

**Simple Definition**: A database schema is like a blueprint or architectural plan for a database. Just as a building blueprint shows the structure, layout, and specifications of a house, a database schema defines the structure, organization, and rules for how data is stored and accessed in a database.

**Technical Definition**: A database schema serves as a blueprint for the shape and format of data within a database, describing categories of data and their connections through tables, relationships, keys, data types, indexes, and constraints.

**Key Analogies**:
- **Blueprint Analogy**: Like a house blueprint shows rooms, doors, and electrical wiring, a schema shows tables, relationships, and data flow
- **Library Catalog System**: Like how a library organizes books by categories, genres, and cataloging rules, a schema organizes data into structured, searchable formats
- **City Planning**: Like how a city has zones (residential, commercial), roads connecting them, and rules governing development, a schema has tables, relationships, and constraints

### Why Schemas Matter

Database schemas are crucial because they:

**1. Provide Structure and Organization**
- Transform raw data into organized, queryable information
- Enable the database engine to understand data patterns
- Create a foundation for efficient data retrieval and manipulation

**2. Ensure Data Integrity**
- Enforce rules about what data can be stored and how
- Prevent inconsistencies and errors
- Maintain data quality over time

**3. Enable Performance Optimization**
- Allow databases to optimize queries based on known structures
- Support indexing strategies for faster data access
- Enable efficient storage and retrieval patterns

**4. Facilitate Collaboration**
- Provide clear documentation for developers and administrators
- Enable multiple applications to work with the same data consistently
- Support maintenance and evolution of database systems

### Schema vs. Database vs. Table

Understanding the hierarchy and relationships between these concepts is essential:

**Database**
- The complete data storage system
- Contains multiple schemas (in some systems) or represents the entire data environment
- Example: A company's entire customer management system

**Schema**
- The structural blueprint within a database
- Defines how data is organized and related
- Can be logical (conceptual design) or physical (implementation details)
- Example: The structure defining how customer data, orders, and products relate

**Table**
- Individual data containers within a schema
- Composed of rows (records) and columns (fields)
- Represents a specific entity or concept
- Example: A "Customers" table with columns for name, email, and address

**Relationship Hierarchy**:
```
Database
├── Schema
    ├── Tables
    │   ├── Columns (Fields)
    │   └── Rows (Records)
    ├── Relationships
    ├── Constraints
    ├── Indexes
    └── Views
```

### Types of Schemas

**1. Logical Schema**
- **Purpose**: Conceptual blueprint focusing on data organization and relationships
- **Characteristics**: Platform-agnostic, focuses on business logic
- **Content**: Entities, attributes, relationships, business rules
- **Use Case**: Initial design phase, communication with stakeholders
- **Example**: "Customers have orders, orders contain products, products have categories"

**2. Physical Schema**
- **Purpose**: Implementation-specific details for actual database creation
- **Characteristics**: Database platform-specific, includes technical specifications
- **Content**: Table names, column data types, indexes, constraints, storage details
- **Use Case**: Database implementation and optimization
- **Example**: "CREATE TABLE customers (id INT PRIMARY KEY, name VARCHAR(255), email VARCHAR(255) UNIQUE)"

**3. Conceptual Schema**
- **Purpose**: High-level view of the entire database
- **Characteristics**: Abstract, focuses on overall data architecture
- **Content**: Major entities and high-level relationships
- **Use Case**: Strategic planning, system architecture decisions
- **Example**: Enterprise-wide view of how customer data flows through different systems

**4. Static vs. Dynamic Schemas**

**Static Schemas** (Relational Databases):
- Defined ahead of time
- Structure enforced by database system
- Changes require explicit schema modifications
- Provides data validation before storage
- Example: Traditional SQL databases like MySQL, PostgreSQL

**Dynamic Schemas** (NoSQL Databases):
- Structure emerges from data patterns
- More flexible, allows varied data structures
- Structure not enforced at database level
- Application handles data validation
- Example: MongoDB, document databases

---

## 2. Core Components & Elements

### Tables and Their Structure

**Tables as Data Containers**
Tables are the fundamental building blocks of relational databases, structured like spreadsheets with rows and columns.

**Table Components**:

**Rows (Records/Tuples)**:
- Individual data entries
- Represent a single instance of an entity
- Example: One customer, one order, one product

**Columns (Fields/Attributes)**:
- Data categories or properties
- Define what type of information is stored
- Have specific data types and constraints
- Example: customer_name, order_date, product_price

**Data Types**
Understanding and choosing appropriate data types is crucial for efficiency and data integrity:

**Text Data Types**:
- `CHAR(n)`: Fixed-length text (e.g., state codes: 'CA', 'NY')
- `VARCHAR(n)`: Variable-length text (e.g., names, addresses)
- `TEXT`: Large amounts of text (e.g., descriptions, comments)

**Numeric Data Types**:
- `INT`: Whole numbers (e.g., quantities, IDs)
- `DECIMAL/NUMERIC`: Precise decimal numbers (e.g., prices, measurements)
- `FLOAT/DOUBLE`: Approximate decimal numbers (e.g., scientific calculations)

**Date and Time Types**:
- `DATE`: Dates only (e.g., birth_date)
- `TIME`: Time only (e.g., appointment_time)
- `DATETIME/TIMESTAMP`: Date and time (e.g., order_created_at)

**Other Common Types**:
- `BOOLEAN`: True/false values (e.g., is_active)
- `BLOB`: Binary data (e.g., images, files)
- `JSON`: Structured data (e.g., preferences, metadata)

### Relationships

Relationships define how tables connect to each other, representing real-world associations between entities.

**One-to-One (1:1) Relationships**
- Each record in Table A relates to exactly one record in Table B
- Relatively uncommon in practice
- Often indicates tables could be combined

**Example**: Person and Passport
```
Person Table:           Passport Table:
ID | Name               ID | PassportNumber | PersonID
1  | John Smith         1  | A123456789     | 1
2  | Jane Doe           2  | B987654321     | 2
```

**When to Use 1:1**:
- Separating optional data (avoiding empty fields)
- Security considerations (sensitive data in separate table)
- Performance optimization (frequently vs. rarely accessed data)

**One-to-Many (1:M) Relationships**
- Most common relationship type
- One record in the parent table relates to multiple records in the child table
- Implemented using foreign keys

**Example**: Customer and Orders
```
Customer Table:         Orders Table:
ID | Name               ID | OrderDate  | CustomerID
1  | John Smith         1  | 2024-01-15 | 1
2  | Jane Doe           2  | 2024-01-20 | 1
                        3  | 2024-01-25 | 2
```

**Many-to-Many (M:N) Relationships**
- Multiple records in Table A relate to multiple records in Table B
- Cannot be directly implemented in relational databases
- Requires a junction (link) table to break into two 1:M relationships

**Example**: Students and Courses
```
Students Table:         Courses Table:           Enrollments Table:
ID | Name               ID | CourseName           StudentID | CourseID | Grade
1  | Alice              1  | Math 101             1         | 1        | A
2  | Bob                2  | History 201          1         | 2        | B+
3  | Carol              3  | Science 301          2         | 1        | A-
                                                 3         | 2        | B
```

### Keys

Keys are essential for identifying records and establishing relationships between tables.

**Primary Keys (PK)**
- Uniquely identifies each record in a table
- Cannot be NULL or empty
- Cannot be duplicated
- Should be stable (not frequently changed)

**Characteristics of Good Primary Keys**:
- Unique across all records
- Never NULL
- Rarely or never changed
- Simple (preferably single column)
- Meaningful within the business context

**Examples**:
- Good: Employee ID, Order Number, ISBN
- Poor: Email address (can change), Phone number (can change), Name (not unique)

**Composite Keys**:
- Primary key made up of multiple columns
- Useful when no single column can uniquely identify records
- Example: OrderID + ProductID in an order details table

**Foreign Keys (FK)**
- References the primary key of another table
- Establishes and enforces relationships between tables
- Maintains referential integrity

**Example**:
```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);
```

**Other Key Types**:
- **Unique Keys**: Ensure uniqueness but allow NULL values
- **Candidate Keys**: All possible choices for primary key
- **Surrogate Keys**: Artificial keys (like auto-incrementing IDs)
- **Natural Keys**: Keys with business meaning (like Social Security Numbers)

### Constraints

Constraints enforce data integrity rules at the database level.

**Common Constraint Types**:

**NOT NULL**
- Ensures a column cannot have empty values
- Essential for critical data fields
- Example: Customer name, order date

**UNIQUE**
- Ensures all values in a column are different
- Allows NULL values (unlike PRIMARY KEY)
- Example: Email addresses, usernames

**CHECK**
- Validates data against custom conditions
- Enforces business rules at database level
- Example: Age must be between 0 and 120, Price must be positive

**DEFAULT**
- Provides automatic values when none specified
- Reduces data entry errors
- Example: Creation timestamp, status flags

**FOREIGN KEY**
- Maintains referential integrity between tables
- Prevents orphaned records
- Can cascade changes or restrict deletions

**Example Implementation**:
```sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    FirstName VARCHAR(50) NOT NULL,
    LastName VARCHAR(50) NOT NULL,
    Email VARCHAR(100) UNIQUE,
    Age INT CHECK (Age >= 18 AND Age <= 65),
    HireDate DATE DEFAULT CURRENT_DATE,
    DepartmentID INT,
    FOREIGN KEY (DepartmentID) REFERENCES Departments(DepartmentID)
);
```

### Indexes

Indexes are data structures that improve query performance by creating shortcuts to data.

**How Indexes Work**:
- Like a book's index, they point to where data is located
- Create sorted references to table data
- Trade storage space for query speed
- Must be maintained when data changes

**Types of Indexes**:

**Clustered Index**:
- Physically reorders table data
- Only one per table (usually on primary key)
- Data pages stored in order of index key

**Non-Clustered Index**:
- Separate structure pointing to data rows
- Multiple non-clustered indexes per table
- Doesn't change physical data order

**Composite Index**:
- Built on multiple columns
- Order of columns matters for query optimization
- Example: Index on (LastName, FirstName) for name searches

**When to Use Indexes**:
- Columns frequently used in WHERE clauses
- Columns used in JOIN conditions
- Columns used in ORDER BY clauses
- Foreign key columns

**Index Trade-offs**:
- **Benefits**: Faster SELECT queries, improved JOIN performance
- **Costs**: Slower INSERT/UPDATE/DELETE operations, additional storage space

### Views

Views are virtual tables created by saved queries that simplify data access and enhance security.

**What Views Provide**:
- Simplified access to complex data
- Security through data abstraction
- Consistent data presentation
- Logical data independence

**Types of Views**:

**Simple Views**:
- Based on single table
- Can often be updated
- Example: Active customers only

**Complex Views**:
- Based on multiple tables or complex queries
- Usually read-only
- Example: Customer order summaries with totals

**Materialized Views**:
- Physically stored query results
- Faster access but requires refresh
- Used for reporting and analytics

**Example View**:
```sql
CREATE VIEW ActiveCustomers AS
SELECT 
    CustomerID,
    FirstName,
    LastName,
    Email,
    RegistrationDate
FROM Customers 
WHERE Status = 'Active' 
  AND LastLoginDate > DATE_SUB(NOW(), INTERVAL 90 DAY);
```

**Benefits of Views**:
- Hide complexity from users
- Provide consistent data access patterns
- Implement row-level security
- Support legacy applications during schema changes

---

## 3. Design Principles & Best Practices

### Normalization

Normalization is the process of organizing data to reduce redundancy and improve data integrity.

**Goals of Normalization**:
- Eliminate data redundancy
- Prevent update anomalies
- Ensure data consistency
- Optimize storage efficiency

**First Normal Form (1NF)**

**Rules**:
- Each cell contains only one value (atomic values)
- No repeating groups or arrays
- Each row is unique

**Violation Example**:
```
ProductID | Colors
1         | red, blue, green
2         | yellow, orange
```

**1NF Solution**:
```
ProductID | Color
1         | red
1         | blue
1         | green
2         | yellow
2         | orange
```

**Second Normal Form (2NF)**

**Rules**:
- Must be in 1NF
- All non-key attributes must be fully dependent on the entire primary key
- Eliminates partial dependencies

**Violation Example** (Composite key: OrderID + ProductID):
```
OrderID | ProductID | ProductName | ProductPrice | OrderDate
1001    | 101       | Widget A    | $10.00       | 2024-01-15
1001    | 102       | Widget B    | $15.00       | 2024-01-15
```

**Problem**: ProductName and ProductPrice depend only on ProductID, not the full key.

**2NF Solution**:
```
Orders Table:
OrderID | OrderDate
1001    | 2024-01-15

Products Table:
ProductID | ProductName | ProductPrice
101       | Widget A    | $10.00
102       | Widget B    | $15.00

OrderDetails Table:
OrderID | ProductID | Quantity
1001    | 101       | 2
1001    | 102       | 1
```

**Third Normal Form (3NF)**

**Rules**:
- Must be in 2NF
- No transitive dependencies (non-key attributes depending on other non-key attributes)

**Violation Example**:
```
EmployeeID | DepartmentID | DepartmentName | DepartmentManager
1001       | 10           | Sales          | John Smith
1002       | 10           | Sales          | John Smith
1003       | 20           | Marketing      | Jane Doe
```

**Problem**: DepartmentName and DepartmentManager depend on DepartmentID, not EmployeeID.

**3NF Solution**:
```
Employees Table:
EmployeeID | DepartmentID
1001       | 10
1002       | 10
1003       | 20

Departments Table:
DepartmentID | DepartmentName | DepartmentManager
10           | Sales          | John Smith
20           | Marketing      | Jane Doe
```

### Denormalization

Sometimes breaking normalization rules improves performance or simplifies queries.

**When to Denormalize**:
- Read-heavy applications where query performance is critical
- Data warehouse and reporting systems
- When JOIN operations become too expensive
- When data rarely changes

**Denormalization Strategies**:

**Calculated Fields**:
- Store computed values to avoid recalculation
- Example: Order total instead of calculating from line items

**Redundant Data**:
- Duplicate frequently accessed data
- Example: Customer name in orders table

**Summary Tables**:
- Pre-calculated aggregations
- Example: Monthly sales totals

**Example**: E-commerce order summary
```sql
-- Normalized approach requires JOIN
SELECT o.OrderID, c.CustomerName, SUM(od.Quantity * od.Price) as Total
FROM Orders o
JOIN Customers c ON o.CustomerID = c.CustomerID
JOIN OrderDetails od ON o.OrderID = od.OrderID
GROUP BY o.OrderID, c.CustomerName;

-- Denormalized approach with redundant data
SELECT OrderID, CustomerName, OrderTotal
FROM Orders_Denormalized;
```

### Naming Conventions

Consistent naming conventions improve readability and maintainability.

**Table Naming Conventions**:
- Use descriptive, business-meaningful names
- Consistent plural/singular usage (prefer plural)
- Use PascalCase or snake_case consistently
- Examples: `Customers`, `OrderDetails`, `ProductCategories`

**Column Naming Conventions**:
- Use descriptive names
- Avoid abbreviations unless well-known
- Include units where applicable
- Examples: `FirstName`, `OrderDate`, `PriceInCents`, `WeightInPounds`

**Key Naming Conventions**:
- Primary keys: `TableName + ID` (e.g., `CustomerID`)
- Foreign keys: Match referenced primary key name
- Composite keys: Combine component names

**Constraint Naming Conventions**:
- Include constraint type and table name
- Examples: `PK_Customers`, `FK_Orders_CustomerID`, `CK_Employees_Age`

**Index Naming Conventions**:
- Include table name and column names
- Examples: `IX_Customers_LastName`, `IX_Orders_OrderDate_CustomerID`

### Data Integrity Principles

**Entity Integrity**:
- Every table must have a primary key
- Primary key values must be unique and not NULL
- Ensures each row can be uniquely identified

**Referential Integrity**:
- Foreign key values must match existing primary key values
- Prevents orphaned records
- Maintains consistency across related tables

**Domain Integrity**:
- Data values must be valid for their data type
- Enforced through data types, constraints, and validation rules
- Examples: Dates must be valid dates, numbers within acceptable ranges

**User-Defined Integrity**:
- Business-specific rules and constraints
- Implemented through CHECK constraints, triggers, or application logic
- Examples: Employee salary must be positive, order date cannot be in the future

### Scalability Considerations

**Vertical Scaling Strategies**:
- Optimize queries and indexes
- Use appropriate data types
- Implement efficient normalization
- Regular maintenance and statistics updates

**Horizontal Scaling Strategies**:
- Partitioning tables across multiple databases
- Sharding based on key attributes
- Read replicas for read-heavy applications
- Caching strategies for frequently accessed data

**Performance Optimization Strategies**:

**Query Optimization**:
- Use appropriate indexes
- Avoid SELECT * statements
- Use LIMIT clauses for large result sets
- Optimize JOIN operations

**Storage Optimization**:
- Choose appropriate data types
- Compress large text fields
- Archive old data
- Use appropriate file organization

**Maintenance Strategies**:
- Regular index rebuilding
- Statistics updates
- Database health monitoring
- Capacity planning

---

## 4. Practical Design Process

### Step-by-Step Schema Design Workflow

**Phase 1: Requirements Analysis**

**1. Understand the Business Domain**
- Interview stakeholders and end users
- Analyze existing systems and processes
- Review business forms and documents
- Identify key business rules and constraints

**2. Identify Data Requirements**
- What data needs to be stored?
- How will the data be used?
- What are the performance requirements?
- What are the security and compliance requirements?

**3. Define Success Criteria**
- Performance benchmarks
- Data quality standards
- Scalability requirements
- User experience goals

**Phase 2: Conceptual Design**

**1. Identify Entities**
- Major business objects (customers, orders, products)
- Events (transactions, appointments)
- Concepts (categories, statuses)

**2. Define Attributes**
- Properties of each entity
- Data types and constraints
- Optional vs. required fields

**3. Identify Relationships**
- How entities relate to each other
- Cardinality of relationships
- Business rules governing relationships

### Requirements Gathering and Analysis

**Interview Techniques**:

**Stakeholder Questions**:
- "What business problems are we trying to solve?"
- "What reports do you need to generate?"
- "What data do you currently track manually?"
- "What are your peak usage times?"

**User Questions**:
- "How do you currently perform this task?"
- "What information do you need to see together?"
- "How often do you need to access this data?"
- "What would make your job easier?"

**Technical Questions**:
- "What are the expected data volumes?"
- "What are the performance requirements?"
- "What are the backup and recovery needs?"
- "What are the security requirements?"

**Analysis Deliverables**:
- Requirements document
- Use case scenarios
- Data dictionary (preliminary)
- Performance requirements specification

### Entity-Relationship (ER) Modeling

**ER Diagram Components**:

**Entities** (Rectangles):
- Represent business objects
- Named with singular nouns
- Example: Customer, Order, Product

**Attributes** (Ovals):
- Properties of entities
- Include data types and constraints
- Identify primary keys (underlined)

**Relationships** (Diamonds):
- Connections between entities
- Named with verbs
- Example: "Customer places Order"

**Cardinality Indicators**:
- 1:1 (one-to-one)
- 1:M (one-to-many)
- M:N (many-to-many)

**ER Modeling Process**:

**Step 1: Identify Entities**
Example for e-commerce system:
- Customer
- Order
- Product
- Category
- Payment
- Shipping Address

**Step 2: Define Attributes**
Customer Entity:
- CustomerID (Primary Key)
- FirstName
- LastName
- Email
- Phone
- RegistrationDate

**Step 3: Identify Relationships**
- Customer places Order (1:M)
- Order contains Product (M:N)
- Product belongs to Category (M:1)
- Order has Payment (1:1)

**Step 4: Resolve Many-to-Many Relationships**
Create OrderDetails entity to resolve Order-Product M:N relationship:
- OrderID (FK)
- ProductID (FK)
- Quantity
- UnitPrice

### Converting ER Diagrams to Schema

**Conversion Rules**:

**1. Each Entity becomes a Table**
```sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    FirstName VARCHAR(50) NOT NULL,
    LastName VARCHAR(50) NOT NULL,
    Email VARCHAR(100) UNIQUE,
    Phone VARCHAR(20),
    RegistrationDate DATE DEFAULT CURRENT_DATE
);
```

**2. Each Attribute becomes a Column**
- Choose appropriate data types
- Add constraints based on business rules
- Set default values where appropriate

**3. Relationships become Foreign Keys**
```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT NOT NULL,
    OrderDate DATE DEFAULT CURRENT_DATE,
    Status VARCHAR(20) DEFAULT 'Pending',
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);
```

**4. Many-to-Many Relationships become Junction Tables**
```sql
CREATE TABLE OrderDetails (
    OrderID INT,
    ProductID INT,
    Quantity INT NOT NULL,
    UnitPrice DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (OrderID, ProductID),
    FOREIGN KEY (OrderID) REFERENCES Orders(OrderID),
    FOREIGN KEY (ProductID) REFERENCES Products(ProductID)
);
```

### Schema Validation and Testing

**Validation Checklist**:

**Data Integrity**:
- All tables have primary keys
- Foreign key relationships are properly defined
- Constraints enforce business rules
- Data types are appropriate

**Normalization**:
- Tables are properly normalized (usually to 3NF)
- Redundancy is minimized
- Update anomalies are eliminated

**Performance**:
- Indexes are defined for frequently queried columns
- Query performance meets requirements
- Storage requirements are reasonable

**Testing Strategies**:

**1. Sample Data Testing**
- Create representative test data
- Test all CRUD operations
- Verify constraint enforcement
- Check referential integrity

**2. Performance Testing**
- Load test with expected data volumes
- Measure query response times
- Test concurrent user scenarios
- Monitor resource usage

**3. Edge Case Testing**
- Test with boundary values
- Test with NULL values
- Test constraint violations
- Test cascade operations

**Example Test Cases**:
```sql
-- Test primary key constraint
INSERT INTO Customers (CustomerID, FirstName, LastName, Email) 
VALUES (1, 'John', 'Doe', 'john@example.com');

-- This should fail (duplicate primary key)
INSERT INTO Customers (CustomerID, FirstName, LastName, Email) 
VALUES (1, 'Jane', 'Smith', 'jane@example.com');

-- Test foreign key constraint
INSERT INTO Orders (OrderID, CustomerID, OrderDate) 
VALUES (1, 999, '2024-01-15'); -- Should fail if CustomerID 999 doesn't exist

-- Test check constraint
INSERT INTO Products (ProductID, ProductName, Price) 
VALUES (1, 'Widget', -10.00); -- Should fail if price must be positive
```

---

## 5. Real-World Examples

### Complete Schema Examples

**E-commerce Database Schema**

This comprehensive example demonstrates a typical online store database structure:

**Core Tables**:

```sql
-- Customers table
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY AUTO_INCREMENT,
    FirstName VARCHAR(50) NOT NULL,
    LastName VARCHAR(50) NOT NULL,
    Email VARCHAR(100) UNIQUE NOT NULL,
    Phone VARCHAR(20),
    DateOfBirth DATE,
    RegistrationDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    Status ENUM('Active', 'Inactive', 'Suspended') DEFAULT 'Active'
);

-- Categories table
CREATE TABLE Categories (
    CategoryID INT PRIMARY KEY AUTO_INCREMENT,
    CategoryName VARCHAR(100) NOT NULL,
    Description TEXT,
    ParentCategoryID INT,
    FOREIGN KEY (ParentCategoryID) REFERENCES Categories(CategoryID)
);

-- Products table
CREATE TABLE Products (
    ProductID INT PRIMARY KEY AUTO_INCREMENT,
    ProductName VARCHAR(200) NOT NULL,
    Description TEXT,
    CategoryID INT NOT NULL,
    Price DECIMAL(10,2) NOT NULL CHECK (Price > 0),
    StockQuantity INT NOT NULL DEFAULT 0,
    SKU VARCHAR(50) UNIQUE,
    Weight DECIMAL(8,2),
    Dimensions VARCHAR(50),
    IsActive BOOLEAN DEFAULT TRUE,
    CreatedDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (CategoryID) REFERENCES Categories(CategoryID)
);

-- Addresses table (for shipping/billing)
CREATE TABLE Addresses (
    AddressID INT PRIMARY KEY AUTO_INCREMENT,
    CustomerID INT NOT NULL,
    AddressType ENUM('Shipping', 'Billing') NOT NULL,
    FirstName VARCHAR(50) NOT NULL,
    LastName VARCHAR(50) NOT NULL,
    AddressLine1 VARCHAR(100) NOT NULL,
    AddressLine2 VARCHAR(100),
    City VARCHAR(50) NOT NULL,
    State VARCHAR(50) NOT NULL,
    PostalCode VARCHAR(20) NOT NULL,
    Country VARCHAR(50) NOT NULL DEFAULT 'USA',
    IsDefault BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

-- Orders table
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY AUTO_INCREMENT,
    CustomerID INT NOT NULL,
    OrderDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    Status ENUM('Pending', 'Processing', 'Shipped', 'Delivered', 'Cancelled') DEFAULT 'Pending',
    ShippingAddressID INT NOT NULL,
    BillingAddressID INT NOT NULL,
    SubTotal DECIMAL(10,2) NOT NULL,
    TaxAmount DECIMAL(10,2) NOT NULL DEFAULT 0,
    ShippingCost DECIMAL(10,2) NOT NULL DEFAULT 0,
    TotalAmount DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID),
    FOREIGN KEY (ShippingAddressID) REFERENCES Addresses(AddressID),
    FOREIGN KEY (BillingAddressID) REFERENCES Addresses(AddressID)
);

-- Order Details table (junction table for orders and products)
CREATE TABLE OrderDetails (
    OrderID INT,
    ProductID INT,
    Quantity INT NOT NULL CHECK (Quantity > 0),
    UnitPrice DECIMAL(10,2) NOT NULL,
    LineTotal DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (OrderID, ProductID),
    FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE CASCADE,
    FOREIGN KEY (ProductID) REFERENCES Products(ProductID)
);

-- Payments table
CREATE TABLE Payments (
    PaymentID INT PRIMARY KEY AUTO_INCREMENT,
    OrderID INT NOT NULL,
    PaymentMethod ENUM('Credit Card', 'Debit Card', 'PayPal', 'Bank Transfer') NOT NULL,
    PaymentStatus ENUM('Pending', 'Completed', 'Failed', 'Refunded') DEFAULT 'Pending',
    Amount DECIMAL(10,2) NOT NULL,
    TransactionID VARCHAR(100),
    PaymentDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (OrderID) REFERENCES Orders(OrderID)
);
```

**Key Design Features**:
- **Flexible Address System**: Supports multiple addresses per customer
- **Hierarchical Categories**: Self-referencing for category trees
- **Comprehensive Order Tracking**: From creation to delivery
- **Financial Integrity**: Separate payment tracking with transaction IDs
- **Audit Trail**: Timestamps for key events

**Library Management System Schema**

```sql
-- Authors table
CREATE TABLE Authors (
    AuthorID INT PRIMARY KEY AUTO_INCREMENT,
    FirstName VARCHAR(50) NOT NULL,
    LastName VARCHAR(50) NOT NULL,
    Biography TEXT,
    BirthDate DATE,
    Nationality VARCHAR(50)
);

-- Publishers table
CREATE TABLE Publishers (
    PublisherID INT PRIMARY KEY AUTO_INCREMENT,
    PublisherName VARCHAR(100) NOT NULL,
    Address VARCHAR(200),
    ContactPhone VARCHAR(20),
    ContactEmail VARCHAR(100)
);

-- Books table
CREATE TABLE Books (
    BookID INT PRIMARY KEY AUTO_INCREMENT,
    ISBN VARCHAR(13) UNIQUE NOT NULL,
    Title VARCHAR(200) NOT NULL,
    PublisherID INT NOT NULL,
    PublicationYear YEAR,
    Pages INT,
    Language VARCHAR(50) DEFAULT 'English',
    Genre VARCHAR(50),
    Description TEXT,
    FOREIGN KEY (PublisherID) REFERENCES Publishers(PublisherID)
);

-- Book Authors junction table (many-to-many)
CREATE TABLE BookAuthors (
    BookID INT,
    AuthorID INT,
    Role ENUM('Author', 'Co-Author', 'Editor') DEFAULT 'Author',
    PRIMARY KEY (BookID, AuthorID),
    FOREIGN KEY (BookID) REFERENCES Books(BookID),