# Keys in depth

## Relational Database Design: Keys for Uniqueness and Relationships

In relational database design, **keys** are fundamental for uniquely identifying records within a table and for establishing crucial relationships between different tables. They are essential for querying specific data and maintaining data integrity.

### 1. Primary Key (PK)

The Primary Key is the unique identifier for each record within its _own_ table.

- **Purpose**:
  - To **uniquely identify** each row (record) in a table. This is crucial when records might otherwise have duplicate values in other columns (e.g., two students named "Mary" or with the same "Date of Birth").
  - To **prevent duplicates** of entire records.
  - To serve as the **reference point** for Foreign Keys in other tables.
    ![](../0.Pics/PK.png)
- **Properties**:
  - **Unique**: Each value in the Primary Key column(s) must be unique across all rows in the table.
  - **Not Null**: A Primary Key column cannot contain `NULL` (empty) values. Every record must have a value for its Primary Key.
- **Identifying a Primary Key (Candidate Keys)**:
  - A **Candidate Key** is any attribute (column) or set of attributes that is unique for each row and cannot have a null value.
  - From the available candidate keys, one is chosen to be the **Primary Key**.
  - The candidate keys that are _not_ chosen as the Primary Key become **Alternate (or Secondary) Keys**.
    - _Example_: In a `Student` table, `ID` and `Email` might both be unique candidate keys. If `ID` is chosen as the Primary Key, then `Email` becomes an Alternate Key.
- **Types of Primary Keys**:
  1.  **Simple Primary Key (Single-Column PK)**:
      - A single column whose values uniquely identify each record.
      - _Example_: The `ID` column in a `Student` table.
        ![](../0.Pics/compositeKey.png)
  2.  **Composite Primary Key (Multi-Column PK)**:
      - A combination of **two or more attributes (columns)** that, when taken together, form a unique value for each record.
      - Used when no single column in a table can uniquely identify a record on its own.
      - _Example_: In a `Deliveries` table, `Order ID` alone might not be unique (e.g., `Or10` appears twice). `Customer ID` alone might not be unique (e.g., `Cu01` appears twice). However, the combination of `(Order ID, Customer ID, Product Code)` might be unique for each specific delivery instance.

### 2. Foreign Key (FK)

A Foreign Key is a column (or set of columns) in one table that references the Primary Key in another table, establishing a relationship between them.

- **Purpose**:
  - To **connect two tables** and create **cross-referencing** between them.
  - To establish and enforce **relationships** between data in different entities (tables).
  - Allows you to determine which records in the "child" table are associated with specific records in the "parent" table (e.g., which customer made which order).
  - Crucial for maintaining **referential integrity**, ensuring that relationships between tables remain valid.
    ![foreignKey_withERD](../0.Pics/foreignKey_withERD.png)
- **Concept**:
  ![alt text](../0.Pics/image.png)

  - The Foreign Key in one table (`child table`) points to (or refers to) the Primary Key in an **external/foreign table** (`parent table`).

  - The values in the Foreign Key column(s) of the child table **must correspond to existing values** in the referenced Primary Key column(s) of the parent table.
  - It is not necessary for a child record to exist for a parent record, but a child record cannot exist without a corresponding parent record.

- **Relationships & Foreign Keys**:
  - **One-to-Many (1:M) Relationship**: This is the most common use of Foreign Keys. The PK from the "one" side (parent) becomes the FK in the "many" side (child).
    - _Example_: In a bookstore database, `customer_id` (PK in `Customer` table) is added as a `FOREIGN KEY` in the `Order` table. This means one customer can place many orders, but each order belongs to only one customer. The `Customer` table is the parent, and `Order` is the child.
  - **Multiple Foreign Keys**: A table can have more than one foreign key, allowing it to connect to multiple "parent" tables.
    - _Example_: An `Order` table might have both `customer_id` (referencing `Customer` table) and `product_id` (referencing `Product` table) as foreign keys. In this scenario, `Customer` and `Product` tables are both "parents" to the `Order` "child" table.
      ![twoForeignKeys](../0.Pics/twoForeignKeys.png)
  - **One-to-One (1:1) Relationship**: Can also use Foreign Keys, often by making the FK also unique.
  - **Many-to-Many (M:N) Relationship**: These are typically resolved by creating an **associative (junction) table** that contains foreign keys referencing the primary keys of both original tables.

**In essence, Primary Keys ensure uniqueness within a table, while Foreign Keys bridge tables together, defining crucial relationships and maintaining the integrity of interconnected data.**

In a relational database, the primary key can be selected from any candidate key attribute that contains a unique instance value in each row of the table.

Review the following vehicle table. Can you identify the candidate key attributes?

**Vehicle table**

| **Vehicle ID** | **Owner ID** | **Car plate number** | **Owner phone number** |
| -------------- | ------------ | -------------------- | ---------------------- |
| D01            | Ow01         | PL02NY               | 0738297294             |
| D02            | Ow02         | SN02L2               | 0725021582             |
| D03            | Ow03         | PK02L2               | 0765021583             |

This table includes three candidate keys:

- the vehicle ID,
- the car plate number,
- and the owner’s phone numbers.

Each of these three keys holds unique values in the related column in all rows. Therefore, each of those attributes can potentially act as a primary key column for the vehicle table and could be used to uniquely identify each record in the table. You might notice that there are unique values in all rows that belong to the owner ID. So, is the owner ID a fourth candidate key?

Well, it is correct that the owner ID column has unique values in all rows of the table in the given example. However, it's possible that the same owner may buy another car and will then have multiple cars. So, it’s not a good idea to choose this column, because if someone owns multiple cars then the owner ID will no longer be unique. For example, if an owner buys three cars, then their owner ID repeats itself three times in the table. This means that it’s no longer unique and thus cannot be chosen as a primary key.

But which of the three attributes would be the best candidate to act as a primary key? The vehicle plate number could be problematic. The owner might choose to change the vehicle plate number by purchasing a private plate number. In this instance, the vehicle plate number associated with the owner would change. This would require updating the plate number wherever it exists in the database. However, in case none of the values are updated, or if they’re updated with a wrong number, this will cause confusion and can sometimes even cause serious errors and problems.

Similarly, the owner phone number can’t be considered as a primary key because this candidate key value may change if the owner changes their phone number. This will then lead to the same type of problem that you could encounter with the number plate candidate key.

When you design a table in your database, you must make sure to choose a candidate key with a value that cannot change. The vehicle ID candidate key is unique and not expected to change so it should be your primary key. The entity relationship diagram below shows the primary key of the table in bold and underlined.

![Untitled](../0.Pics/vehicle_ERD.png)

## **Create the database**

`CREATE DATABASE automobile;`

```sql
CREATE TABLE Vehicle(
  VehicleID VARCHAR(10) NOT NULL,
  OwnerID VARCHAR(10),
  PlateNumber VARCHAR(10),
  PhoneNumber INT,
  PRIMARY KEY (VehicleID)
);
```

Now any candidate key that has not been chosen to act as the primary key of the vehicle table is called an `alternate key`. That’s the plate number and phone number.

Also, it’s important to remember that a primary key can be composed of one single simple attribute or multiple attributes (a composite key), which is composed of two or more attributes that form a unique value in each row of the table. This usually happens when a single attribute cannot be found to act as a primary key.

Now let’s build another table to maintain data about the vehicles’ owners. This table includes information about the owner's name and address as illustrated below.

**Owner table**

| Owner ID | Owner name     | Owner address       |
| -------- | -------------- | ------------------- |
| Ow01     | Amjad Omer     | 110, Elephant Way   |
| Ow02     | Hans Henderson | 120, Dragon Way     |
| Ow03     | Paulo Galdames | 130, Giraffe Avenue |

The owner ID is the primary key in this table, as it will always be unique. Whereas the owner's name could be the same for different owners, and the owner address could be the same for different owners living at the same address. This would violate the uniqueness requirement for the primary key.

Now create the Owner table in the automobile database. Remember to declare the ownerID as the primary key of the table.

```sql
CREATE TABLE Owner(
ownerID VARCHAR(10) NOT NULL,
ownerName VARCHAR(50),
ownerdrerss  VARCHAR(255),
PRIMARY KEY (ownerID)
);
```

By now you have two tables created in the automobile database. The vehicle table contains information about the vehicle ID, owner ID, plate number and phone number. Whereas the owner table contains information about the owner ID, owner name and address.

You may have noticed that the owner ID is a common attribute, as it exists in both tables. However, the key difference is that it is a primary key in the owner table. This means it must be unique in each row of the table. Yet it might be duplicated in the vehicle table, because the same owner might have multiple vehicles. This means that the owner ID in the vehicle table is a suitable choice for a foreign key that connects the vehicle table with the owner table as shown in the following ER diagram.

![Untitled](../0.Pics/ownerId.png)

This diagram shows the cross-reference between the two tables. The owner ID column represents the foreign key in the vehicle table that refers to the external primary key column in the owner table. This ensures that each vehicle is associated with the right owner. Also, according to the diagram, the relationship is one-to-many, where each owner may own many cars.

To create this relationship in the actual database you need to modify the vehicle table structure to make the owner ID a foreign key. This can be done by using the “ALTER” command to change the structure of the vehicle table. You can also use the "ADD” command to define the owner ID as the foreign key. Finally, you can use a "REFERENCES” keyword to reference it with the primary key in the owner table.

```sql
ALTER TABLE vehicle ADD FOREIGN KEY (ownerID) REFERENCES owner (ownerID);
```

You will notice that the owner ID key has been changed into a MUL key, which is one of the three possible values for the "key" attribute in MySQL.

![](../0.Pics/vehicle_table.png)

- PRI comes from primary; this means it’s a primary key.
- UNI comes from unique; this means it’s a unique key.
- MUL comes from multiple. If the key is MUL, it means that the related column is permitted to contain the same value in multiple cells of that column.

In this reading, you learned how to choose the primary key from a set of candidate keys. In addition, you learned how to alter the structure of the table to associate two tables by using the foreign key.

The `CONSTRAINT` keyword in

```sql
CREATE TABLE Staff( Email VARCHAR(200) NOT NULL, Name varchar(255) NOT NULL, CONSTRAINT PK_Email PRIMARY KEY (Email));
```

statement is used to **define a constraint with a specific, user-defined name**.

Let's break down the line: `CONSTRAINT PK_Email PRIMARY KEY (Email)`

- **`CONSTRAINT`**: This keyword signals to SQL that you are about to define a constraint.
- **`PK_Email`**: This is the **name you are giving to this specific primary key constraint**.
  - **Why name it?**
    - **Readability**: It makes your schema easier to understand, especially for complex databases with many constraints.
    - **Error Messages**: When a constraint is violated (e.g., you try to insert a duplicate email), the database will often include the constraint name in the error message, making it much easier to diagnose the problem.
    - **Management**: If you ever need to `ALTER` or `DROP` this specific constraint later (e.g., `ALTER TABLE Staff DROP CONSTRAINT PK_Email;`), you can refer to it by its name. Without a name, the database would assign a system-generated, often cryptic, name.
- **`PRIMARY KEY (Email)`**: This part defines the actual constraint. It specifies that the `Email` column (or columns, if it were a composite key) is the Primary Key for the `Staff` table. This means:
  - Every value in the `Email` column must be **unique**.
  - The `Email` column cannot contain `NULL` values.

**In summary:**

The `CONSTRAINT PK_Email PRIMARY KEY (Email)` syntax is a way to define a **table-level primary key constraint** and explicitly **give it the name `PK_Email`**. This is generally considered good practice for better database management and debugging.

**Contrast with inline definition:**

You could also define the primary key directly next to the column definition (an "inline" constraint), like this:

```sql
CREATE TABLE Staff (
    Email VARCHAR(200) NOT NULL PRIMARY KEY, -- Primary key defined inline
    Name VARCHAR(255) NOT NULL
);
```

In this inline case, the database would automatically assign a system-generated name to the primary key constraint. Both methods achieve the same functional outcome (making `Email` the primary key), but using `CONSTRAINT name` provides more control and clarity.
