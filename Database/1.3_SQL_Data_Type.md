## SQL Data Type

Data types are crucial in databases for ensuring that each column stores the correct kind of data. They tell the database management system (e.g., MySQL) how to interpret column values, maintain data in the right format, and ensure values are as expected.

There are two primary numeric data types:

**Integer Data Type (INT)**:

- Used for whole numbers (e.g., product quantity).
- If fractional numbers are inserted, they are automatically rounded to the nearest whole number.
- Examples in MySQL include `TINYINT` (for small integers, max 255) and `INT` (for very large integers, max over 4 billion).
- Can typically accept both positive and negative values. Some systems allow forcing columns to accept only positive numbers, which increases their maximum storage capacity.

**Decimal Data Type (DECIMAL)**:

- Used for numbers with fractional values (e.g., total price, like $80.90).
- Whole numbers can also be inserted; the database will add a decimal point and a fractional value of zero (e.g., 80 becomes 80.00).

Different database management systems offer various types of integer and decimal data types, each designed to store a specific range of minimum and maximum values.

When creating database tables, defining column data types is essential for data integrity. **String data types** are used for columns that store text, which can include a mix of alphabetic, numeric, and special characters.

Here's a summary of key string data types:

**CHAR (Character)**:

- Used for fixed-length strings.
- The length is predetermined during declaration and cannot be changed.
- Defined as `CHAR(length)`, e.g., `CHAR(50)`.
- **Space Allocation**: Even if the stored string is shorter than the defined length, it will occupy the _entire_ specified length. For instance, a 7-character username in a `CHAR(50)` column will still consume 50 characters of space.
- Best suited when you know the exact or maximum consistent length of the data.

**VARCHAR (Variable Character)**:

- Used for variable-length strings.
- The length is not fixed and can change based on the actual data inserted.
- Defined as `VARCHAR(maximum_length)`, e.g., `VARCHAR(50)`.
- **Space Allocation**: Only occupies as much space as the actual characters in the string, up to the maximum specified length. A name like "Mark Simpson" in a `VARCHAR(50)` column will only take up the space of its characters, not the full 50.
- Often used when you are unsure about the exact length of the characters that might be inserted.

**Other Commonly Used String Data Types (primarily for longer texts):**

- **TINYTEXT**: Stores less than 255 characters (e.g., short paragraphs).
- **TEXT**: Stores less than 65,000 characters (e.g., an article).
- **MEDIUMTEXT**: Stores up to 16.7 million characters (e.g., the text of a book).
- **LONGTEXT**: Stores up to 4 gigabytes of text data.

Understanding these string data types allows you to efficiently store and manage textual information in your database tables.

### Default Values

**Database Constraints** are rules applied to database tables to limit the type of data that can be stored, ensuring data accuracy and reliability. If an operation violates a constraint, the database aborts the operation.

Constraints can be:

- **Column-level**: Applied to a specific column.
- **Table-level**: Applied to the entire table (e.g., `FOREIGN KEY` constraints, prevent
  actions that will destroy links between tables).

Two commonly used constraints are `NOT NULL` and `DEFAULT`.

1. `NOT NULL` Constraint

- **Purpose**: Ensures that data fields in a specified column are _always_ completed and can never be left blank (i.e., they cannot contain a `NULL` value).
- **Example**: In a `Customer` table with `customer_id` and `customer_name` columns, if both are `NOT NULL`, any attempt to create a new customer record without providing values for these columns will fail.

**SQL Implementation**: Declared when creating the table, next to the column's data type:

```sql
CREATE TABLE Customer (
    customer_id INT NOT NULL,
    customer_name VARCHAR(255) NOT NULL
);
```

Any `INSERT` or `UPDATE` operation attempting to place a `NULL` value into these `NOT NULL` columns will be rejected.

2. `DEFAULT` Constraint

- **Purpose**: Sets a default value for a column. If no value is explicitly specified for that column during an `INSERT` operation, the predefined default value is automatically inserted instead.
- **Example**: In a `Player` table with a `city` column, if most players are from Barcelona, you can set "Barcelona" as the default city. This saves time as you don't need to manually enter "Barcelona" for every new player from that city.

**SQL Implementation**: Declared when creating the table, next to the column's data type, using the `DEFAULT` keyword:

```sql
CREATE TABLE Player (
    player_name VARCHAR(255) NOT NULL,
    city VARCHAR(255) DEFAULT 'Barcelona'
);
```

Now, when adding data for a new player, if the `city` is not specified, it will automatically default to 'Barcelona'.

```sql
CREATE TABLE Players
(
    playerName VARCHAR(50),
    club VARCHAR (10)
    DEFAULT "Newport FC", city
    VARCHAR (100) DEFAULT "Newport"
);
```

**In summary**:

- **Constraints** maintain data quality and integrity.
- **`NOT NULL`** prevents empty fields where data is always required.
- **`DEFAULT`** provides a fallback value for fields when no explicit value is provided.

### MySQL Data Types

The w3resource.com page on MySQL Data Types provides a comprehensive overview of the various data types available in MySQL, categorized into Numeric, Date and Time, and String types. It also includes details on their storage requirements, ranges, and common uses.

Here's a summary of the key information you'll need for revision:

**1. Importance of Data Types:**

- Data types define the kind of data a column can hold.
- They ensure data integrity, accuracy, and efficient storage.
- MySQL supports standard SQL data types.

**2. Numeric Types:**

- **Integer Types:** Used for whole numbers. MySQL extends standard SQL with more specific integer types, each with a defined range and byte length.
  - `TINYINT`: 1 byte, range -128 to 127 (signed), 0 to 255 (unsigned).
  - `SMALLINT`: 2 bytes, range -32768 to 32767 (signed), 0 to 65535 (unsigned).
  - `MEDIUMINT`: 3 bytes, range -8388608 to 8388607 (signed), 0 to 16777215 (unsigned).
  - `INT` (or `INTEGER`): 4 bytes, range approx. $\pm 2$ billion (signed), 0 to 4 billion (unsigned).
  - `BIGINT`: 8 bytes, very large range approx. $\pm 9 \times 10^{18}$ (signed), 0 to $1.8 \times 10^{19}$ (unsigned).
  - **Signed vs. Unsigned**: Unsigned types only store non-negative numbers, effectively doubling the positive range.
- **Fixed-Point Types (Exact Numeric):**
  - `DECIMAL(p, s)` and `NUMERIC(p, s)`: Store exact decimal values.
    - `p` (precision): total number of digits.
    - `s` (scale): number of digits after the decimal point.
    - Example: `DECIMAL(5,2)` can store numbers like 123.45.
- **Floating-Point Types (Approximate Numeric):**
  - `FLOAT`: Single-precision floating-point numbers (4 bytes).
  - `DOUBLE` (or `DOUBLE PRECISION`, `REAL`): Double-precision floating-point numbers (8 bytes).
  - These types store approximate values and are subject to rounding errors.

**3. Date and Time Types:**

- **`DATE`**: Stores only date values.
  - Format: 'YYYY-MM-DD'
  - Range: '1000-01-01' to '9999-12-31'
- **`DATETIME`**: Stores both date and time values.
  - Format: 'YYYY-MM-DD HH:MM:SS'
  - Range: '1000-01-01 00:00:00' to '9999-12-31 23:59:59'
- **`TIMESTAMP`**: Stores date and time values, with automatic conversion between the current time zone and UTC.
  - Format: 'YYYY-MM-DD HH:MM:SS'
  - Range: '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC (due to historical limitations, though this is expanding in newer MySQL versions).
- **`TIME`**: Stores only time values.
  - Format: 'HH:MM:SS'
- **`YEAR`**: Stores year values.
  - Can be 2-digit or 4-digit format, with specific ranges and interpretations.

**4. String Types:**

- **Character Strings (Non-binary):**
  - `CHAR(length)`: Fixed-length string. If the actual string is shorter, it's right-padded with spaces. Trailing spaces are removed on retrieval. Max length 255 characters.
  - `VARCHAR(length)`: Variable-length string. Only occupies space for the actual characters stored. Max length 65,535 characters (in MySQL 5.0.3+).
  - **Key difference between CHAR and VARCHAR**: `CHAR` consumes fixed space, `VARCHAR` consumes variable space.
- **Binary Strings:**
  - `BINARY(length)`: Fixed-length binary string. Similar to `CHAR` but for binary data.
  - `VARBINARY(length)`: Variable-length binary string. Similar to `VARCHAR` but for binary data.
- **Large Object (LOB) Types:**
  - Used for very large text or binary data.
  - **`TEXT` Types (for character data):**
    - `TINYTEXT`: Max 255 characters.
    - `TEXT`: Max 65,535 characters.
    - `MEDIUMTEXT`: Max 16,777,215 characters.
    - `LONGTEXT`: Max 4,294,967,295 characters (4GB).
  - **`BLOB` Types (for binary data):**
    - `TINYBLOB`: Max 255 bytes.
    - `BLOB`: Max 65,535 bytes.
    - `MEDIUMBLOB`: Max 16,777,215 bytes.
    - `LONGBLOB`: Max 4,294,967,295 bytes (4GB).
  - These types do not require a specified length during column creation as they store a variable amount of data up to their maximum capacity.

**5. Other Data Types (briefly mentioned or implied):**

- `BOOLEAN`: Though MySQL uses `TINYINT(1)` internally for true/false.
- `ENUM` and `SET`: For predefined lists of values (not explicitly detailed in the provided snippet but are common string types in MySQL).

### Decimal and Numeric (Transact-SQL)

The Microsoft Learn documentation on `DECIMAL` and `NUMERIC` data types in Transact-SQL (SQL Server) explains these as **exact numeric data types with fixed precision and scale**. This means they are designed to store numbers precisely, without the rounding errors that can occur with floating-point types like `FLOAT` or `REAL`.

Here's a summary of the key information:

**1. Synonyms and Functionality:**

- `DECIMAL` and `NUMERIC` are **synonyms** and can be used interchangeably in SQL Server. They function identically.
- They are used for fixed-precision and fixed-scale numbers.

**2. Arguments (`p`, `s`):**

- **`p` (precision)**: Represents the **maximum total number of decimal digits** that can be stored, both to the left and right of the decimal point.
  - Range: 1 to 38.
  - Default precision: 18.
- **`s` (scale)**: Represents the **number of decimal digits stored to the right of the decimal point**.
  - Range: 0 to `p`.
  - Can only be specified if `p` (precision) is also specified.
  - Default scale: 0.

**3. Range of Values:**

- When maximum precision (38 digits) is used, valid values range from $-10^{38} + 1$ to $10^{38} - 1$.

**4. Storage Size:**

- The storage size for `DECIMAL` and `NUMERIC` varies based on the precision (`p`). The higher the precision, the more bytes required.
  - For example, precision 1-9 typically takes 5 bytes, while 29-38 takes 17 bytes.

**5. How SQL Server Handles `DECIMAL`/`NUMERIC`:**

- **Distinct Data Types**: SQL Server considers each unique combination of precision and scale as a different data type. For example, `DECIMAL(5,2)` and `DECIMAL(5,0)` are treated as distinct types.
- **Automatic Conversion of Constants**: A constant with a decimal point in a Transact-SQL statement is automatically converted to a `NUMERIC` value with the minimum precision and scale needed to represent it. For instance, `12.345` becomes `NUMERIC(5,3)`.
- **Rounding during Conversion**: By default, SQL Server uses rounding when converting a number to a `DECIMAL` or `NUMERIC` value with lower precision and/or scale.
- **Overflow Handling**: If `SET ARITHABORT` is `ON`, an error is raised when an overflow occurs during conversion (i.e., the value is too large for the specified precision). Losing only precision and scale (due to rounding) is not sufficient to raise an error by itself.

**6. Conversion Risks:**

- **`DECIMAL`/`NUMERIC` to `FLOAT` or `REAL`**: Possible loss of precision due to the approximate nature of floating-point types.
- **`INT`, `SMALLINT`, etc., `FLOAT`, `REAL`, `MONEY`, etc. to `DECIMAL`/`NUMERIC`**: Possible overflow if the source value is too large for the target `DECIMAL`/`NUMERIC`'s defined precision.

**7. Use Cases:**

- These data types are crucial for applications requiring exact numeric behavior, especially in financial calculations, where precision is paramount and rounding errors are unacceptable.

**Key takeaway for MySQL:**

When you need absolute precision for numbers (e.g., for money), always choose DECIMAL (or NUMERIC) over FLOAT or DOUBLE in MySQL, just as you would in SQL Server. While the maximum precision (M) might differ slightly (65 in MySQL vs. 38 in SQL Server), the core concept and purpose are the same across these major database systems

**In essence:** `DECIMAL` and `NUMERIC` are your go-to data types in SQL Server when you need to store numbers with absolute precision, controlling both the total number of digits and the number of digits after the decimal point. They are functionally identical and critical for financial and other precise numeric data.
